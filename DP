### **动态规划（Dynamic Programming, DP）概述**
动态规划是一种解决最优化问题的算法思想，主要通过将问题分解为更小的子问题来解决。与分治法不同，动态规划通过存储子问题的解来避免重复计算，从而优化时间复杂度。

---

### **动态规划的核心思想**
1. **重叠子问题（Overlapping Subproblems）**  
   一个问题可以分解为多个子问题，且这些子问题在计算过程中会重复出现。

2. **最优子结构（Optimal Substructure）**  
   问题的全局最优解可以通过子问题的最优解来构建。

3. **状态转移方程（State Transition Equation）**  
   动态规划的核心在于找出递推关系，即状态转移方程。它描述了如何从已求解的子问题推导出当前问题的解。

---

### **动态规划的实现步骤**
1. **定义状态（Define States）**  
   确定问题的子状态，一般通过一个数组或矩阵来表示。
   - 示例：`dp[i]` 表示到第 `i` 个位置的最优解。

2. **状态转移方程（State Transition Formula）**  
   写出状态间的递推关系，通常需要分析问题的特点和约束条件。
   - 示例：斐波那契数列的转移方程：`dp[i] = dp[i-1] + dp[i-2]`

3. **初始化（Initialization）**  
   确定边界条件，给出问题的初始状态。
   - 示例：`dp[0] = 0`, `dp[1] = 1`

4. **计算顺序（Iteration Order）**  
   根据递推关系，按照正确的顺序计算状态。

5. **返回结果（Return Result）**  
   根据问题需求返回最终结果，通常是 `dp` 数组的一个特定位置。

---

### **动态规划的分类**
1. **线性动态规划**  
   问题的状态依赖于单一维度。  
   示例：斐波那契数列、最长递增子序列。

2. **二维动态规划**  
   问题的状态依赖于两个维度。  
   示例：背包问题、最长公共子序列。

3. **区间动态规划**  
   状态依赖于某个区间的值。  
   示例：矩阵链乘法问题。

4. **树形动态规划**  
   状态定义在树的节点上，状态间根据树的结构递推。  
   示例：树的直径、树的最小覆盖问题。

---

### **Python 动态规划示例**
#### 1. 斐波那契数列
```python
def fibonacci(n):
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

#### 2. 01 背包问题
```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    
    return dp[n][capacity]
```

---

### **动态规划的优缺点**
#### 优点：
- 避免重复计算，提高算法效率。
- 可以解决很多复杂的最优化问题。

#### 缺点：
- 需要额外的存储空间。
- 有些问题的状态和转移方程较难设计。
